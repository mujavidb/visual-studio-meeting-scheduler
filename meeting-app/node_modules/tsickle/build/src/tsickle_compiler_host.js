"use strict";
var ts = require('typescript');
var decorator_annotator_1 = require('./decorator-annotator');
var es5processor_1 = require('./es5processor');
var modules_manifest_1 = require('./modules_manifest');
var tsickle_1 = require('./tsickle');
(function (Pass) {
    Pass[Pass["None"] = 0] = "None";
    Pass[Pass["DecoratorDownlevel"] = 1] = "DecoratorDownlevel";
    Pass[Pass["Tsickle"] = 2] = "Tsickle";
})(exports.Pass || (exports.Pass = {}));
var Pass = exports.Pass;
/**
 * TsickleCompilerHost does tsickle processing of input files, including
 * closure type annotation processing, decorator downleveling and
 * require -> googmodule rewriting.
 */
var TsickleCompilerHost = (function () {
    function TsickleCompilerHost(delegate, options, environment, oldProgram, pass) {
        if (pass === void 0) { pass = Pass.None; }
        this.delegate = delegate;
        this.options = options;
        this.environment = environment;
        this.oldProgram = oldProgram;
        this.pass = pass;
        this.ANNOTATION_SUPPORT = "\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n";
        // The manifest of JS modules output by the compiler.
        this.modulesManifest = new modules_manifest_1.ModulesManifest();
        /** Error messages produced by tsickle, if any. */
        this.diagnostics = [];
        /** externs.js files produced by tsickle, if any. */
        this.externs = {};
    }
    TsickleCompilerHost.prototype.reconfigureForRun = function (program, pass) {
        this.oldProgram = program;
        this.pass = pass;
    };
    TsickleCompilerHost.prototype.getSourceFile = function (fileName, languageVersion, onError) {
        if (this.pass === Pass.None) {
            return this.delegate.getSourceFile(fileName, languageVersion, onError);
        }
        if (!this.oldProgram) {
            throw new Error('tried to run a pass other than None without setting a program');
        }
        var sourceFile = this.oldProgram.getSourceFile(fileName);
        switch (this.pass) {
            case Pass.DecoratorDownlevel:
                return this.runDecoratorDownlevel(sourceFile, this.oldProgram, fileName, languageVersion);
            case Pass.Tsickle:
                return this.runTsickle(sourceFile, this.oldProgram, fileName, languageVersion);
            default:
                throw new Error('tried to use TsickleCompilerHost with unknown pass enum');
        }
    };
    TsickleCompilerHost.prototype.writeFile = function (fileName, content, writeByteOrderMark, onError, sourceFiles) {
        fileName = this.delegate.getCanonicalFileName(fileName);
        if (this.options.googmodule && !fileName.match(/\.d\.ts$/)) {
            content = this.convertCommonJsToGoogModule(fileName, content);
        }
        this.delegate.writeFile(fileName, content, writeByteOrderMark, onError, sourceFiles);
    };
    TsickleCompilerHost.prototype.convertCommonJsToGoogModule = function (fileName, content) {
        var moduleId = this.environment.fileNameToModuleId(fileName);
        var _a = es5processor_1.processES5(fileName, moduleId, content, this.environment.pathToModuleName.bind(this.environment), this.options.es5Mode, this.options.prelude), output = _a.output, referencedModules = _a.referencedModules;
        var moduleName = this.environment.pathToModuleName('', fileName);
        this.modulesManifest.addModule(fileName, moduleName);
        for (var _i = 0, referencedModules_1 = referencedModules; _i < referencedModules_1.length; _i++) {
            var referenced = referencedModules_1[_i];
            this.modulesManifest.addReferencedModule(fileName, referenced);
        }
        return output;
    };
    TsickleCompilerHost.prototype.runDecoratorDownlevel = function (sourceFile, program, fileName, languageVersion) {
        if (this.environment.shouldSkipTsickleProcessing(fileName))
            return sourceFile;
        var fileContent = sourceFile.text;
        var converted = decorator_annotator_1.convertDecorators(program.getTypeChecker(), sourceFile);
        if (converted.diagnostics) {
            (_a = this.diagnostics).push.apply(_a, converted.diagnostics);
        }
        if (converted.output === fileContent) {
            // No changes; reuse the existing parse.
            return sourceFile;
        }
        fileContent = converted.output + this.ANNOTATION_SUPPORT;
        return ts.createSourceFile(fileName, fileContent, languageVersion, true);
        var _a;
    };
    TsickleCompilerHost.prototype.runTsickle = function (sourceFile, program, fileName, languageVersion) {
        var isDefinitions = /\.d\.ts$/.test(fileName);
        // Don't tsickle-process any d.ts that isn't a compilation target;
        // this means we don't process e.g. lib.d.ts.
        if (isDefinitions && this.environment.shouldSkipTsickleProcessing(fileName))
            return sourceFile;
        var _a = tsickle_1.annotate(program, sourceFile, { untyped: !this.options.tsickleTyped }), output = _a.output, externs = _a.externs, diagnostics = _a.diagnostics;
        if (externs) {
            this.externs[fileName] = externs;
        }
        if (this.environment.shouldIgnoreWarningsForPath(sourceFile.path)) {
            // All diagnostics (including warnings) are treated as errors.
            // If we've decided to ignore them, just discard them.
            // Warnings include stuff like "don't use @type in your jsdoc"; tsickle
            // warns and then fixes up the code to be Closure-compatible anyway.
            diagnostics = diagnostics.filter(function (d) { return d.category === ts.DiagnosticCategory.Error; });
        }
        this.diagnostics = diagnostics;
        return ts.createSourceFile(fileName, output, languageVersion, true);
    };
    /** Concatenate all generated externs definitions together into a string. */
    TsickleCompilerHost.prototype.getGeneratedExterns = function () {
        var allExterns = '';
        for (var _i = 0, _a = Object.keys(this.externs); _i < _a.length; _i++) {
            var fileName = _a[_i];
            allExterns += "// externs from " + fileName + ":\n";
            allExterns += this.externs[fileName];
        }
        return allExterns;
    };
    // Delegate everything else to the original compiler host.
    TsickleCompilerHost.prototype.fileExists = function (fileName) {
        return this.delegate.fileExists(fileName);
    };
    TsickleCompilerHost.prototype.getCurrentDirectory = function () {
        return this.delegate.getCurrentDirectory();
    };
    ;
    TsickleCompilerHost.prototype.useCaseSensitiveFileNames = function () {
        return this.delegate.useCaseSensitiveFileNames();
    };
    TsickleCompilerHost.prototype.getNewLine = function () {
        return this.delegate.getNewLine();
    };
    TsickleCompilerHost.prototype.getDirectories = function (path) {
        return this.delegate.getDirectories(path);
    };
    TsickleCompilerHost.prototype.readFile = function (fileName) {
        return this.delegate.readFile(fileName);
    };
    TsickleCompilerHost.prototype.getDefaultLibFileName = function (options) {
        return this.delegate.getDefaultLibFileName(options);
    };
    TsickleCompilerHost.prototype.getCanonicalFileName = function (fileName) {
        return this.delegate.getCanonicalFileName(fileName);
    };
    return TsickleCompilerHost;
}());
exports.TsickleCompilerHost = TsickleCompilerHost;

//# sourceMappingURL=tsickle_compiler_host.js.map
